# SA-MP 脚本机制详解：单线程、更新与同步

原作者：Slice

我注意到很多人脚本中出现的各种 bug 和问题，很多都是由于对这个领域的知识不足导致的。读完这篇文章后，我希望能帮大家澄清一些概念。

## 主题：

* 脚本运行在单线程
* 玩家更新
* 影响玩家的服务器函数
* 按键同步
* 数据包丢失（进阶）
* 数据包乱序（进阶）

## 脚本运行在单线程

这对一些人来说可能听起来很复杂，让我来解释一下：服务器执行的所有操作，总是等待上一个操作完全完成后才会进行下一个。

例如，如果你在 `OnPlayerConnect` 中写了一段需要执行 3 秒的代码（比如老的 GeoIP 插件），那么服务器会等待这段代码执行完毕后，才会处理其他任何事情。

可能会占用大量时间的操作：

* 处理超长字符串
* 循环遍历所有玩家并执行多个操作
* 大量读写文件

服务器必须等待这些操作全部完成；因此，请尽量让你的代码保持高效和快速。

### 优势

在我看来，服务器使用单线程的好处在于，你可以完全控制信息流入服务器的流程；你会按照服务器接收到的顺序依次处理每一个动作。如果服务器是多线程的，那么在你的代码运行过程中，玩家信息可能会被异步更新。老实说，我不认为那样会更好。

## 玩家更新

当客户端的以下任何数据发生变化时，客户端会向服务器发送信息，服务器会调用 `OnPlayerUpdate`：

* 生命值/护甲值
* 载具生命值、车身损伤、颜色、改装件
* 死亡
* 速度
* 位置/旋转角度
* 动画
* 按下的按键
* 武器/弹药
* 相机位置（仅在瞄准/射击时；否则大约每秒发送两次）

通过脚本，你几乎可以精确地在 `OnPlayerUpdate` 中检测到究竟是哪些数据发生了变化。

**当玩家移动摄像头、开始移动，随后按下动作键时会发生什么？**

1. 如果玩家正在瞄准/射击，相机角度和面向角度会在同一个更新包中发送，并调用 `OnPlayerUpdate`。如果玩家没有瞄准/射击，此时 `OnPlayerUpdate` 可能调用也可能不调用（很可能不调用）。
2. `OnPlayerUpdate` 会因为新的按键状态而被调用；`OnPlayerKeyStateChange` 不会被调用，因为按键是左右或上下方向。如果动画瞬间发生变化，它会在 `OnPlayerUpdate` 调用之前先更新。

**注意**：我不确定动画是否会和按键处于同一个更新包中，目前无法测试。

`GetPlayerAnimationIndex` 返回的 ID 会随着客户端初始化新动画而立即变化。例如，当你开始奔跑时，动画会在你按下移动键的那一刻就发生变化（即使你可能不会立刻察觉）。

### 在 `OnPlayerUpdate` 中返回 0 会发生什么？

`OnPlayerUpdate` 是在服务器将新信息发送给其他玩家**之前**被调用的。如果你 在任何一个 `OnPlayerUpdate`（过滤脚本或游戏模式）中返回 0，那么这次更新将不会被发送给其他客户端。

### 良好用法示例

这可以防止玩家被冻结时还能射击或移动/瞬移。不再有“幽灵射击”之类的问题！

```pawn
new
    bool:g_IsPlayerFroze[ MAX_PLAYERS ] // 为每个玩家存储一个变量，表示是否已被冻结
;

public OnPlayerSpawn( playerid )
{
    g_IsPlayerFroze[ playerid ] = false; // 玩家重生时总是解除冻结
}

public OnPlayerUpdate( playerid )
{
    static // 使用 static 变量是因为不需要每次执行函数都重新初始化
        s_Keys,
        s_UpDown,
        s_LeftRight
    ;
    
    GetPlayerKeys( playerid, s_Keys, s_UpDown, s_LeftRight ); // 获取当前按下的按键
    
    if ( g_IsPlayerFroze[ playerid ] && ( s_Keys || s_UpDown || s_LeftRight ) ) // 如果按下了任何按键，则不同步此次更新
        return 0;
    
    return 1;
}

// 使用以下两个函数来冻结/解冻玩家

stock FreezePlayer( playerid )
{
    g_IsPlayerFroze[ playerid ] = true; // 服务器现在将该玩家视为已冻结状态
    
    TogglePlayerControllable( playerid, false );
}

stock UnfreezePlayer( playerid )
{
    g_IsPlayerFroze[ playerid ] = false; // 与上面相反！
    
    TogglePlayerControllable( playerid, true );
}
```

### 错误用法示例

下面的代码中没有 `return 1`，导致**所有**玩家的更新都不会被同步。

```pawn
public OnPlayerUpdate( playerid )
{
    if ( GetPlayerWeapon( playerid ) == WEAPON_MINIGUN )
        Ban( playerid );
}
```

**改进后的代码：**

```pawn
public OnPlayerUpdate( playerid )
{
    if ( GetPlayerWeapon( playerid ) == WEAPON_MINIGUN )
        Ban( playerid );
    
    return 1;
}
```

## 影响玩家的服务器函数

像 `SetPlayerHealth`、`GivePlayerMoney`、`PutPlayerInVehicle` 等函数，都只会从服务器向**被影响的玩家**单独发送一条消息（`SetPlayerVirtualWorld` 是例外）。

### 这意味着什么？

假设玩家当前生命值为 73，你使用 `SetPlayerHealth` 将其设置为 100，会发生以下过程：

1. `SetPlayerHealth(playerid, 100.0)` → 服务器向对应客户端发送消息，告诉它将生命值更新为 100。
2. 客户端当前处于暂停状态，消息被放入队列，等待玩家取消暂停并按顺序处理完之前的消息。
3. 游戏模式中的定时器调用 `GetPlayerHealth`，显示的仍然是 73。
4. 客户端取消暂停，队列中的所有消息依次被处理。
5. 客户端的生命值被更新。
6. 客户端向服务器发送一个更新。
7. `OnPlayerUpdate` 被调用。
8. 新的生命值被发送给服务器上的其他所有玩家，他们现在看到该玩家生命值为 100！

## 按键同步

SA-MP 的同步方式是：将你按下的按键复制并应用到其他所有客户端上。如果你按下瞄准并射击，其他客户端上你也会按下瞄准并射击；这意味着，即使在你的屏幕上你在射击，你在其他玩家屏幕上可能正站在一辆不同步的载具前，或被汽车爆炸刀杀/炸死。这被称为**不同步（desync）**。

### 修复不同步的玩家

修复不同步玩家的唯一正确方法是让玩家流出/流入（stream in/out）或者重生玩家。流出/流入大约需要一秒钟的时间；因此，重生玩家是最常用的解决方案。

我之后会提供完整的重新同步代码！

## 发送到服务器的按键

有些人可能认为，如果非常快速地按下并松开一个按键，服务器可能看不到。错了！例如，如果你快速按下并松开射击键，服务器会收到两次更新：你按下射击，和你松开射击。

## 数据包丢失

有时候，当一个玩家更新被发送到服务器时，它可能会在网络中丢失。这可能会导致脚本出现 bug 或问题；请为数据包丢失做好准备！

### 如何避免因数据包丢失导致的脚本 bug？

永远不要完全信任客户端，无论它是善意还是恶意的。你永远不知道客户端是脚本小子想搞破坏的人、网速很差的人，还是单纯遇到随机丢包的人。

数据包丢失通常会导致玩家信息混乱，例如：

* 玩家 1 有 50 点护甲。
* 服务器有一个基于玩家更新的全新顶级反护甲外挂检测系统！
* 该系统会检测护甲是否发生变化，且玩家在军火店时没有花费 240 元。

1. 玩家 1 进入军火店。服务器通过 `OnPlayerInteriorChange` 中的代码知道了这一点。
2. 玩家 1 购买护甲，向服务器发送带有新护甲值和支付 240 元的更新。
3. 玩家 1 发送数据包给服务器；该数据包丢失了！
4. 玩家 1 开始移动，发送了移动更新，但服务器对 240 元和护甲一无所知。
5. 玩家 1 被击中，新护甲值随玩家更新发送到服务器。服务器仍然不知道 240 元的事！
6. 服务器反外挂系统检测到护甲异常，封禁了玩家。

**防止这种误封：**

* 通知管理员，并将事件记录到隐藏的“可疑作弊计数”（例如累计 3 次后才封禁）。
* 给玩家 1 元钱并等待新的金钱更新；或者暂时移除护甲，只有在接下来的 1-3 次玩家更新中收到新的金钱更新时才重新给予。

## 数据包乱序

数据包乱序是指消息没有按照发送顺序被接收。

一个场景：

* 玩家 1 有 85 点护甲。
* 服务器有全新顶级反护甲检测。

1. 玩家 1 正在生死战斗！
2. 玩家 1 被击中两次，先掉 10 血再掉 20 血；两个带有新护甲值的包被发送到服务器。
3. 数据包错序；服务器先收到消息说玩家护甲为 55（85-10-20）。
4. 第一个数据包随后到达，护甲值为 75。
5. 服务器认为玩家的护甲增加了，从而判定为护甲外挂并封禁。

**防止这种误封：**

* 通知管理员并记录到“可疑作弊计数”。
* 在收到后续 2-3 次玩家更新之前不要采取任何行动，仅生成警告。
* 仅当新护甲值大于或等于 100 时才采取行动。

希望你从这篇教程中学到了一些东西。如果我提供了错误或模糊的信息，请告诉我！我可能会继续补充这个主题的内容。
