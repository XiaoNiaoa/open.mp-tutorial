
# 【教程】二进制与二进制运算符的深入解析

**作者：Kyosaur**

## 目录
- 二进制
- 什么是二进制
- 位的深入解析
- 有符号整数
- 无符号整数
- 二进制运算符
- 位与（Bitwise AND）
- 位或（Bitwise OR）
- 位异或（Bitwise XOR）
- 位非（Bitwise NOT）
- 位移位（Bit Shifting）
- 算术移位（Arithmetic shifts）
  - 右移
  - 左移
- 逻辑移位（Logical Shifts）
  - 右移
  - 左移

## 什么是二进制？

二进制是一种使用两个独特符号来表示数字的数制系统。相比之下，更常见的十进制系统使用十个数字（**基数 10**），而二进制只使用 0 和 1。这听起来在日常生活中似乎毫无用处，但二进制对计算机来说至关重要。计算机在最底层通过操纵电流的流动来表示“开”和“关”状态，从而进行所有计算。这正是二进制的本质——无数个开关的开启与关闭。对大多数人来说这是一个陌生的概念，因此让我们将十进制和二进制系统并列对比一下。

**十进制（基数 10）**

```pawn
0
1
2
3
4
5
6
7
8
9
10
11
12
13
```

**二进制（基数 2）**

```pawn
0   // 0
1   // 1
10  // 2
11  // 3
100 // 4
101 // 5
110 // 6
111 // 7
1000 // 8
1001 // 9
1010 // 10
1011 // 11
1100 // 12
1101 // 13
```

并列观察两个系统，你会发现它们的行为完全相同。一旦到达最后一个可用数字，就必须进位到下一个位置。二进制中的这些位置称为**位**（binary digits 的缩写），本质上是 2 的幂；正如十进制中的位置是 10 的幂一样。为了证明这一点，让我们用标准记法来看数字 13。

**注意：** 以下示例中的 '^' 表示幂运算，而不是位异或（稍后会讲解）。

**十进制（基数 10）**

```pawn
13

// 等于

1 * (10^1) + 3 * (10^0)

// 等于

10 + 3

// 等于

13
```

**二进制（基数 2）**

```pawn
1101

// 等于

1 * (2^3) + 1 * (2^2) + 0 * (2^1) + 1 * (2^0)

// 等于

8 + 4 + 0 + 1

// 等于

13
```

从上面的例子可以看出，如果某一位是 0，我们可以直接忽略它继续计算；毕竟任何数乘以 0 结果都是 0。前面的例子稍微复杂了一些，只是为了绝对清晰。当你从二进制转换时，真正需要做的只是把所有置 1 的位的对应 2 的幂相加即可。

以下是 12 个 2 的幂（我随手列出）：

```pawn
4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1
```

如果你对幂运算一无所知，这可能完全没有意义。幂就是一个数自身相乘 x 次。有了这个概念，前面的幂列表就容易理解了（除了 1 之外）。你可能会好奇为什么 2^0 等于 1，我只能说它就是这样。

```pawn
2^1 = 2, 2^2 = 4, 2^3 = 8
```

我们可以看出，向右移动时，前一个值乘以 2；因此向左移动时，新值就是前一个数除以 2。由此你可以理解 2^0 为什么等于 1。如果你觉得不够满意，可以在网上搜索更多证明。话不多说，让我们来看最后一个稍微复杂的例子！

```pawn
111011001011111000 // 242424

// 记住，忽略所有置 0 的位。

1 * (2^17) = 131072
1 * (2^16) = 65536
1 * (2^15) = 32768
1 * (2^13) = 8192
1 * (2^12) = 4096
1 * (2^9)  = 512
1 * (2^7)  = 128
1 * (2^6)  = 64
1 * (2^5)  = 32
1 * (2^4)  = 16
1 * (2^3)  = 8

131072 + 65536 + 32768 + 8192 + 4096 + 512 + 128 + 64 + 32 + 16 + 8
=
242424
```

转换时请记住：第一个幂是 0，所以不要把第 18 位误认为是 2^18。确实有 18 个幂，但包括了 2^0，因此最高幂实际是 17。

## 位的深入解析

大多数编程语言允许不同的数据类型，其存储信息的位数各不相同；但 Pawn 是一种无类型 32 位语言。这意味着 Pawn 始终有 32 位可用于存储信息。那么当信息过多时会发生什么？答案与有符号整数和无符号整数有关。

### 有符号整数

你有没有注意到 Pawn 中的整数过大时会变成负数？这种“回绕”是因为你超过了 Pawn 的最大值：

```pawn
2^31 - 1   // 幂运算，不是位异或。减 1 是因为我们从 0 开始计数（共有 2,147,483,648 个值，但包含 0，所以最大值为 2,147,483,647）

// 等于

2,147,483,647

// 二进制表示为

1111111111111111111111111111111   // 31 位全 1
```

你可能会问为什么不是 2^32 - 1（4,294,967,295）。这就是有符号整数和无符号整数的区别。有符号整数可以存储负数，而无符号整数不能。这听起来好像偏题了，但我保证没有。最大整数不是 2^32-1 的原因在于第 32 位被用作负正值的切换开关。这称为 MSB（最高有效位）。如果 MSB 为 1，数字为负；如果为 0，则为正。很简单，对吧？

在展示几个负数之前，我需要解释 Pawn 如何表示负数。Pawn 使用**二进制补码**（2's complement）系统表示负数，具体做法是：将数字的所有位取反，然后在新数字上加 1。

趁这个概念还在脑海中，让我们看几个负数例子：

```pawn
11111111111111111111111111111111   // 32 位全 1

// 等于

-1

// 以及

11111111111111111111111111111110

// 等于

-2

// 最后

10000000000000000000000000000000

// 等于

-2147483648
```

可见，所有负数都是原正数的所有位取反后再加 1。这在最后一个例子中非常明显，因为最高正整数是 2147483647。

由此可知 Pawn 的整数范围实际上是：

```pawn
-2^31 到 +2^31 - 1
```

### 无符号整数

Pawn 中没有无符号整数，但我加上这一节只是为了平衡。有符号和无符号整数的唯一区别是无符号整数不能存储负值；整数仍然会回绕，但会回绕到 0，而不是负数。

## 二进制运算符

二进制运算符允许你操作位模式中的单个位。以下是可用的位运算符列表：

- **算术位移位**：`>>` 和 `<<`
- **逻辑位移位**：`>>>`
- **位非（补码）**：`~`
- **位与**：`&`
- **位或**：`|`
- **位异或（互斥或）**：`^`

### 位与（Bitwise AND）

**注意：** 不要与逻辑与运算符 `&&` 混淆。

二进制与运算符简单地对两个二进制数每一位进行逻辑与操作。这听起来有点抽象，让我们实际看一下！

```pawn
1100   // 12
&
0100   // 4
=
0100   // 4，因为两者都包含“100”（即 4）
```

这个例子比较简单，再来看一个难一点的：

```pawn
10111000   // 184
&
01001000   // 72
=
00001000   // 8
```

通过例子你应该已经清楚这个运算符的作用了。它对比两个位集，只有**两者**在同一位置都为 1 时，结果该位才为 1。如果没有任何共同的 1，结果就是 0。

### 位或（Bitwise OR）

**注意：** 不要与逻辑或运算符 `||` 混淆。

位或运算符与位与几乎完全相同，唯一区别是：只要两个位模式中**任意一个**在该位为 1，结果该位就为 1。来看几个例子！

```pawn
1100   // 12
|
0100   // 4
=
1100   // 12
```

再看一个例子：

```pawn
10111000   // 184
|
01001000   // 72
=
11111000   // 248
```

这应该很直观了：只要两个数中任意一个在某位为 1，结果该位就为 1。

### 位异或（Bitwise XOR）

这个运算符与位或有点相似，但有区别。使用上面位或的例子，看看你能否发现不同：

```pawn
1100   // 12
^
0100   // 4
=
1000   // 8
```

最后一个例子：

```pawn
10111000   // 184
^
01001000   // 72
=
11110000   // 240
```

位异或与位或的唯一区别是：如果**两者**在同一位置都为 1，结果该位**不会**为 1。

### 位非（Bitwise NOT）

这个运算符会翻转位模式中的每一位：所有 1 变成 0，所有 0 变成 1。

```pawn
~0
=
11111111111111111111111111111111   // -1

// 以及

~100   // 4
=
11111111111111111111111111111011   // -5

// 以及

~1111111111111111111111111111111   // 2147483647（注意不是 -1，-1 是 32 位）
=
10000000000000000000000000000000   // -2147483648（第 32 位为 1）
```

如果你不明白负数为什么“反向”，请重读有符号整数部分。

### 位移位（Bit Shifting）

位移位正如其名：它将一个数中的位向某个方向移动。还记得前面提到 Pawn 有固定的 32 位存储空间吗？当你把数字移出这个范围时会发生什么？答案取决于你使用的移位运算符以及移动方向。

**注意：** 以下例子中，所有二进制数都会写成完整的 32 位，以避免混淆。

#### 算术移位

##### 右移

使用此运算符时，数中的所有位向右移动 x 次。来看一个简单例子：

```pawn
00000000000000000000000000001000   // 8 >> 2 = 00000000000000000000000000000010   // 2
```

从例子可见，每一位都向右移动了两位，左侧填充了两个 0。这些 0 实际上是 MSB（最高有效位）的值，在有符号整数移位时非常重要。使用 MSB 填充是为了保留被移位数的符号。再用同一个例子，但这次是负数：

```pawn
11111111111111111111111111111000   // -8 >> 2 = 11111111111111111111111111111110   // -2
```

显然行为与上例完全相同，只是左侧填充的是 1，这证明了算术右移的填充值就是 MSB。

##### 左移

这是算术右移的完全反操作。它将数中的所有位向左移动 x 次。来看例子：

```pawn
00000000000000000000000000001000   // 8 << 2 = 00000000000000000000000000100000   // 32
```

左移与右移的唯一区别（除了方向）在于填充方式。算术右移用 MSB 填充，而算术左移始终用 0 填充。因为没有需要保留的符号信息（如数的正负）。

```pawn
11111111111111111111111111111000   // -8 << 2 = 11111111111111111111111111100000   // -32
```

看到了吗？虽然填充始终是 0，但数的符号依然保留。你唯一需要担心的是移位过多。如果正数移位超过最大值，它会变成负数；负数移位过多最终会变为 0。

#### 逻辑移位

##### 右移

这是算术左移的反操作。最贴切的描述是它是两种算术移位的混合。来看实际效果！

```pawn
00000000000000000000000000001000   // 8 >>> 2 = 00000000000000000000000000000010   // 2
```

数字 8 的位向右移了 2 次。这与算术右移有什么不同？答案是填充。算术右移用 MSB 填充，而逻辑右移始终用 0 填充（与算术左移相同）。这意味着它不会保留符号，结果始终为正数。为了证明，让我们移位一个负数！

```pawn
11111111111111111111111111111000   // -8 >>> 2 = 00111111111111111111111111111110   // 1073741822
```

这证明使用逻辑右移不会得到任何负数！

##### 左移

不存在逻辑左移，因为它与算术左移完全相同。我加上这一小节只是为了避免任何混淆，同时保持结构平衡。
