# SA-MP 脚本编写实用技巧分享

原作者: Slice

我想分享一些我在 SA-MP 脚本编写中经常使用或觉得非常有用的东西。  
我可能会在这个主题下陆续添加更多内容。如果你有什么想贡献的，欢迎告诉我！

## 当前计划讨论的主题
- 三元运算符
- 简单的 int -> bool 转换
- 最快的字符串循环
- 最快的基础玩家循环
- 简短函数
- 单条语句中执行多个操作
- 在函数结束后立即运行代码
- 消除烦人的标签警告
- “字符数组”（Char-arrays）
- 分割数字字面量
- 枚举中的位标志（进阶）
- 使用逻辑运算符实现极简 if 语句（进阶）
- 使用 `stock const` 高效管理内存（进阶）

---

## 三元运算符
三元运算符是一种接受三个参数的运算符：如果第一个参数为真，则使用紧跟其后的第二个参数；否则使用第三个参数。

其结构如下：
```
条件 ? 真值 : 假值
```

以下是几个例子：

**原始 if-else 写法：**
```pawn
if ( a == b )
    c = d;
else
    c = e;
```

**使用三元运算符：**
```pawn
c = ( a == b ) ? d : e;
//   if-^   then-^   ^-else
```

**更多例子：**
```pawn
SetPlayerColor( playerid, ( Team[ playerid ] == TEAM_ONE ) ? COLOR_RED : COLOR_BLUE );
// 如果玩家在 TEAM_ONE 队伍，则设置为红色，否则设置为蓝色。

GivePlayerWeapon( playerid, ( IsMadnessEnabled() ) ? WEAPON_MINIGUN : WEAPON_FLOWER, 5000 );
// 如果 IsMadnessEnabled 为真，就给玩家一把加特林！

public OnPlayerSpawn( playerid )
{
    SetPlayerHealth( playerid, ( IsSuddenDeathEnabled() ) ? 1.0 : 100.0 );
    
    if ( ( IsPlayerAdmin( playerid ) ) ? SetPlayerPos( playerid, AdminSpawnX, AdminSpawnY, AdminSpawnZ ) : SetPlayerPos( playerid, PlayerSpawnX, PlayerSpawnY, PlayerSpawnZ ) ){}
    // 这里必须用 if 语句包起来，避免 PAWN 编译器产生警告！
}

file = fopen( ( useSpecialFile ) ? ("special_file.txt") : ("normal_file.txt") );
// 字符串需要用括号括起来，否则 PAWN 编译器会报错。

// 你甚至可以在三元运算符内部再嵌套三元运算符！
file = fopen( ( useFile == 1 ) ? ("file1.txt") : ( ( useFile == 2 ) ? ("file2.txt") : ( ( useFile == 3 ) ? ("file3.txt") : ("file0.txt") ) ) );

// 拆解一下：
    new File:file = fopen(
        ( useFile == 1 ) ? ("file1.txt")
            : ( ( useFile == 2 ) ? ("file2.txt")
                : ( ( useFile == 3 ) ? ("file3.txt")
                    : ("file0.txt") ) )
    );
```

---

## 简单的 int -> bool 转换
有时你需要将整数转换为布尔值，正确的方式如下：
```pawn
new myInt = 50;
new bool:myBool = !!myInt;
```
这样，如果 `myInt` 等于 0，则 `myBool` 变为 0（false）；否则变为 1（true）。

---

## 最快的字符串循环
根据我的经验，这是遍历字符串最快的方式：
```pawn
for ( new i, l = strlen( string ); i != l; i++ )
{
    // 处理字符串中的每个字符
}
```

---

## 最快的基础玩家循环
注意：`foreach` 比这个更快，所以标题说的是“基础”玩家循环。
```pawn
for ( new slots = GetMaxPlayers( ), i; i < slots; i++ )
{
    if ( !IsPlayerConnected( i ) )
        continue;
    
    // 针对已连接玩家的代码
}
```

---

## 简短函数
如果你的函数只有一条语句，可以这样声明：
```pawn
stock SomeFunction( someInput )
    return someArray[ someInput / 2 ];
```

---

## 单条语句中执行多个操作
在编程中，语句就是指令——在 PAWN 中，语句之间用分号（`;`）分隔。有时你想把代码压缩到一行，可以这样做：
```pawn
stock KickEx( playerid, reason[] )
    SendClientMessage( playerid, 0xC00000FF, "你被踢了！原因：" ), SendClientMessage( playerid, 0xC00000FF, reason ), Kick( playerid );
// 发送两条客户端消息，然后踢出玩家。

stock DoStuff( playerid )
    return DoFirstThing( playerid ), DoSecondThing( playerid ), DoThirdThing( playerid ), DoLastThing( playerid );
// DoStuff 将返回 DoLastThing 的返回值。

public OnPlayerRequestSpawn( playerid )
{
    if ( !IsPlayerLoggedIn( playerid ) )
        return SendClientMessage( playerid, 0xC00000FF, "你还没有登录！" ), 0;
    // 发送客户端消息并返回 0
    
    return 1;
}
```

---

## 在函数结束后立即运行代码
这其实没什么特别的，但我还是提一下，因为很少看到有人这么做。  
只需设置一个 0 毫秒且不重复的定时器，该函数就会在当前函数结束后几乎立即被调用。

**为什么需要这样做？**  
有时你想在当前函数结束后立即运行某些代码。下面是一个非常实用的函数示例：
```pawn
stock DBResult:db_query_ex( DB:db, query[ ], bool:storeResult = true )
{
    new DBResult:dbrResult = db_query( db, query );
    
    if ( dbrResult )
    {
        if ( storeResult )
            SetTimerEx( "db_query_ex_free", 0, false, "i", _:dbrResult );
        else
            db_free_result( dbrResult );
    }
    
    return dbrResult;
}

forward db_query_ex_free( DBResult:dbrResult );
public  db_query_ex_free( DBResult:dbrResult )
    db_free_result( dbrResult );

// 示例：

public OnFilterScriptInit( )
{
    new DB:db, DBResult:dbrResult, buffer[ 16 ];
    
    db = db_open( "test.db" );
    
    dbrResult = db_query_ex( db, "SELECT 50" );
    
    db_get_field( dbrResult, 0, buffer, sizeof( buffer ) - 1 );
    
    print( buffer );
    
    // 即使脚本在此函数执行过程中出错并中止，结果仍会被释放，避免内存泄漏！
}
```

**在 `OnRconLoginAttempt` 内部使用 `IsPlayerAdmin` 无效**——管理员状态是在该函数执行之后才设置的。示例：
```pawn
new
    bool:g_IsRconAdmin[ MAX_PLAYERS ]
;

public OnPlayerConnect( playerid )
    g_IsRconAdmin[ playerid ] = false;

public OnRconLoginAttempt( ip[ ], password[ ], success ) // 如果在此函数内检查 IsPlayerAdmin，它会返回 false。:(
    SetTimer( "CheckNewRconAdmins", 0, false );

forward CheckNewRconAdmins( );
public  CheckNewRconAdmins( )
{
    for ( new slots = GetMaxPlayers( ), playerid; playerid < slots; playerid++ )
    {
        if ( !g_IsRconAdmin[ playerid ] && IsPlayerAdmin( playerid ) )
        {
            // IsPlayerAdmin 对于未连接的玩家总是返回 false，所以只调用一次函数可以节省性能。
            
            OnPlayerRconLogIn( playerid );
            
            break;
            // 每次函数调用最多只会有一个新管理员，因此可以跳出循环。
        }
    }
}

OnPlayerRconLogIn( playerid )
{
    SendClientMessage( playerid, 0x0000C0FF, "欢迎，Rcon 管理员！" );
}
```

以下是 Y_Less 在帖子中解释他如何使用这一技巧的部分内容：
> 我发现这对于一次性应用大量操作非常有用。如果你查看 YSI 库中的 YSI_td.own，它可以动态更新文本绘图，因此你可以移动它们、改变颜色等。如果你的代码如下：
> ```pawn
> TD_Colour(td, 0xFF0000AA);
> TD_SetShadow(td, 3);
> TD_Font(td, 2);
> ```
> 这将对所有查看该文本绘图的玩家生效，但由于旧系统的工作方式，它会重绘文本绘图三次，而实际上并不需要。之前的解决方法是增加一个额外参数：
> ```pawn
> TD_Colour(td, 0xFF0000AA, false);
> TD_SetShadow(td, 3, false);
> TD_Font(td, 2);
> ```
> 这样只有最后一次更新才会改变外观。而新系统使用了一个与你刚才描述的类似的定时器。所有函数都包含（或类似）以下代码：
> ```pawn
> if (YSI_g_sTimer[td] == -1)
> {
>     YSI_g_sTimer[td] = SetTimerEx("TD_Delay", 0, 0, "i", td);
> }
> ```
> 这样一来，`TD_Delay` 函数总会在最后一次当前更新被应用后才被调用，而无需事先知道用户的代码。

---

## 消除烦人的标签警告
当你将 `Text3D`、`DBResult` 等类型放入 `printf`、`format`、`SetTimerEx`、`CallLocalFunction`、`CallRemoteFunction` 等函数中时，可能会注意到产生了标签警告。  
这并不是你的代码有问题！  
消除警告的方法是清除标签——在参数前加上下划线作为标签即可。

**示例：**
```pawn
new Text3D:t3dTest = Create3DTextLabel( .. ), Text:txTest = TextDrawCreate( .. );

printf( "DEBUG: %d, %d", _:t3dTest, _:txTest );
```

---

## “字符数组”（Char-arrays）
PAWN 支持访问数组中的单个字节，本意是用于处理压缩字符串。不过大多数 SA-MP 原生函数并不支持压缩字符串。  
但你完全可以利用这种数组来优化内存。普通数组可以存储 -2,147,483,648 到 2,147,483,647 之间的值——但很多时候你并不需要这么大的范围，对吧？  
使用压缩字符串数组，你可以存储 0-255 之间的值（是的，不支持负数；-1 会变成 255）。当你确定不需要负数且不会超过 255 时，为什么不节省点内存呢？

```pawn
new bool:g_IsPlayerSomething[ MAX_PLAYERS ]; // 500 个单元格 × 4 字节/单元格 = 2000 字节！
new bool:g_IsPlayerSomething[ MAX_PLAYERS char ]; // 500 字节 = …… 500 字节！
```

如果你在 50 个需要的地方都使用“字符数组”代替普通数组，你将节省 75,000 字节（约 73 KB）。

**注意！**  
访问这些数组时，**需要使用花括号 `{}`**，而不是普通的方括号 `[]`。

**示例：**
```pawn
public OnPlayerConnect( playerid )
{
    g_IsPlayerSomething{ playerid } = false;
//                      ^          ^
}

public OnPlayerSpawn( playerid )
{
//                         v          v
    if ( g_IsPlayerSomething{ playerid } )
    {
        // 处理代码
    }
}
```

---

## 分割数字字面量

> 引用自 Y_Less：  
> 前几天我发现了一个非常小的技巧：你可以像数学中那样分割长的数字字面量。通常的写法：
> ```
> 345,234,148
> ```
> 这里 “,” 用作千位分隔符（有时也用 “.”，但 PAWN 用 “.” 表示小数点）。在 PAWN 中，你可以用 `'` 来实现同样的效果：
> ```
> 345'234'148
> ```
> 你还可以每 4 位分割十六进制数，每 8 位分割二进制数：
> ```
> 0x12FD'39C5
> 0b00000000'11111111'01010101
> ```
> 如你所见，高亮工具可能不喜欢这种写法。

---

## 枚举中的位标志（进阶）
你知道吗，一个变量可以存储 32 个 true/false 值？这样不仅可以节省空间，还能减少代码中的混乱。

你不需要完全理解二进制数系统的工作原理，但我还是推荐了解一下。如果你感兴趣，可以阅读[这个主题](链接)了解更多。

假设你有 100 个针对每个玩家的 true/false（布尔）变量，你将使用 195 KB 的空间。但如果使用 4 个带有位标志的数组，则只需 8 KB 空间。**效果完全相同，但你能节省 187 KB 的空间！**

下面是一个包含宏的示例，简化了使用方法：
```pawn
// 所有宏的用法：BitFlag_X(variable, flag)
#define BitFlag_Get(%0,%1)            ((%0) & (%1))   // 如果标志未设置，返回零（false）。
#define BitFlag_On(%0,%1)             ((%0) |= (%1))  // 开启某个标志。
#define BitFlag_Off(%0,%1)            ((%0) &= ~(%1)) // 关闭某个标志。
#define BitFlag_Toggle(%0,%1)         ((%0) ^= (%1))  // 切换某个标志（true/false 互换）。

enum PlayerFlags:(<<= 1) {
    // 注意：第一个标志必须写上 "= 1"，否则所有标志都会是 0。
    
    PLAYER_IS_LOGGED_IN = 1,   // 0b00000000000000000000000000000001
    PLAYER_HAS_GANG,           // 0b00000000000000000000000000000010
    PLAYER_CAN_BUY_PROPERTIES, // 0b00000000000000000000000000000100
    PLAYER_BLABLA_1,           // 0b00000000000000000000000000001000
    PLAYER_BLABLA_2,           // 0b00000000000000000000000000010000
    PLAYER_BLABLA_3,           // 0b00000000000000000000000000100000
    PLAYER_BLABLA_4,           // 0b00000000000000000000000001000000
    PLAYER_BLABLA_5,           // 0b00000000000000000000000010000000
    PLAYER_BLABLA_6,           // 0b00000000000000000000000100000000
    PLAYER_BLABLA_7,           // 0b00000000000000000000001000000000
    PLAYER_BLABLA_8,           // 0b00000000000000000000010000000000
    PLAYER_BLABLA_9,           // 0b00000000000000000000100000000000
    PLAYER_BLABLA_10,          // 0b00000000000000000001000000000000
    PLAYER_BLABLA_11,          // 0b00000000000000000010000000000000
    PLAYER_BLABLA_12,          // 0b00000000000000000100000000000000
    PLAYER_BLABLA_13,          // 0b00000000000000001000000000000000
    PLAYER_BLABLA_14,          // 0b00000000000000010000000000000000
    PLAYER_BLABLA_15,          // 0b00000000000000100000000000000000
    PLAYER_BLABLA_16,          // 0b00000000000001000000000000000000
    PLAYER_BLABLA_17,          // 0b00000000000010000000000000000000
    PLAYER_BLABLA_18,          // 0b00000000000100000000000000000000
    PLAYER_BLABLA_19,          // 0b00000000001000000000000000000000
    PLAYER_BLABLA_20,          // 0b00000000010000000000000000000000
    PLAYER_BLABLA_21,          // 0b00000000100000000000000000000000
    PLAYER_BLABLA_22           // 0b00000001000000000000000000000000
};

new
    // 创建一个与枚举相同标签的数组
    PlayerFlags:g_PlayerFlags[MAX_PLAYERS]
;

public OnPlayerConnect(playerid) {
    // 0 - 所有标志关闭（false）。必须包含标签以避免警告。
    g_PlayerFlags[playerid] = PlayerFlags:0;
}

public OnPlayerLogIn(playerid) {
    BitFlag_On(g_PlayerFlags[playerid], PLAYER_IS_LOGGED_IN);
    
//  不使用宏的写法：
//  g_PlayerFlags[playerid] |= PLAYER_IS_LOGGED_IN;
}

public OnPlayerJoinGang(playerid) {
    BitFlag_On(g_PlayerFlags[playerid], PLAYER_HAS_GANG);
    
//  不使用宏的写法：
//  g_PlayerFlags[playerid] |= PLAYER_HAS_GANG;
}

public OnPlayerLeaveGang(playerid) {
    BitFlag_Off(g_PlayerFlags[playerid], PLAYER_HAS_GANG);
    
//  不使用宏的写法：
//  g_PlayerFlags[playerid] &= ~PLAYER_HAS_GANG;
}

public OnPlayerUpdate(playerid) {
    // 每隔一次玩家更新执行 DoSomething。
    
    BitFlag_Toggle(g_PlayerFlags[playerid], PLAYER_BLABLA_19);
    
    if (BitFlag_Get(g_PlayerFlags[playerid], PLAYER_BLABLA_19)) {
        DoSomething();
    }
    
//  不使用宏的写法：
//  g_PlayerFlags[playerid] ^= PLAYER_BLABLA_19;
//  
//  if (g_PlayerFlags[playerid] & PLAYER_BLABLA_19) {
//      DoSomething();
//  }
}
```

---

## 使用逻辑运算符实现极简 if 语句（进阶）
你可以用逻辑运算符替代 if 语句，而且全部写在一个语句里！

例如，我写了一个修正版的 `valstr`，当时没多想就这么写了：
```pawn
stock FIXES_valstr(dest[], value, bool:pack = false)
{
    static const cellmin_value[] = !"-2147483648";

    if (value == cellmin)
        pack && strpack(dest, cellmin_value, 12) || strunpack(dest, cellmin_value, 12);
    else
        format(dest, 12, "%d", value), pack && strpack(dest, dest, 12);
    // 注意 format 后面的逗号？参见本主题中的“单条语句中执行多个操作”部分。
}
```
如你所见，逻辑运算符（`&&` 和 `||`）就直接写在外面。

上面的代码，如果**不使用**这个小技巧，会是这样：
```pawn
stock FIXES_valstr(dest[], value, bool:pack = false)
{
    static const cellmin_value[] = !"-2147483648";

    if (value == cellmin) {
        if (pack)
            strpack(dest, cellmin_value, 12);
        else
            strunpack(dest, cellmin_value, 12);
    } else {
        format(dest, 12, "%d", value);
        
        if (pack)
            strpack(dest, dest, 12);
    }
}
```

**几个示例：**
```pawn
a && b();              // 如果 a 为真，执行 b。
a && b() || c();       // 如果 a 为真，执行 b；否则执行 c。
a || b();              // 如果 a 为假，执行 b。
a && b() || c && d();  // 如果 a 为真，执行 b；否则如果 c 为真，执行 d。
a && b() && c();       // 如果 a 为真，执行 b；如果 b 不为假，执行 c。
```

---

## 使用 `stock const` 高效管理内存（进阶）
作者：Y_Less

`stock const`——这是我一段时间前发现但忘记写下来的东西。

**示例：**
```pawn
#include <a_samp>

main()
{
    print("hi");
    print("hi");
}
```

如果使用 `-a` 参数编译，得到汇编代码：
```
CODE 0    ; 0;program exit point
    halt 0

    proc    ; main
    ; line 4
    ; line 5
    push.c 0
    ;$par
    push.c 4
    sysreq.c 0    ; print
    stack 8
    ;$exp
    ; line 6
    push.c c
    ;$par
    push.c 4
    sysreq.c 0    ; print
    stack 8
    ;$exp
    zero.pri
    retn


DATA 0    ; 0
dump 68 69 0 68 69 0 

STKSIZE 1000
```
我加粗了两行：第一行压入数字 `0`，第二行压入数字 `12`（`c`）。`print` 的第一个（也是唯一）参数是待打印字符串的地址。所有字符串字面量都被转换为数据并存储在全局内存中（这里不深入讨论其实际影响，但可以说你可以改变它们）。`dump` 是这个小程序当前的全局内存内容：
```
dump 68 69 0 68 69 0
```
将这些数字转换为 ASCII 码：
```
dump 'h' 'i' '\0' 'h' 'i' '\0'
```
即我们的两个 `"hi"` 字符串——两个相同的字符串副本并不高效。因此我们可以通过显式管理内存来改进：

```pawn
#include <a_samp>

stock const
    C_HI[3] = "hi";

main()
{
    print(C_HI);
    print(C_HI);
}
```

汇编输出：
```
CODE 0    ; 0;program exit point
    halt 0


DATA 0    ; 0
dump 68 69 0 

    proc    ; main
    ; line 7
    ; line 8
    push.c 0
    ;$par
    push.c 4
    sysreq.c 0    ; print
    stack 8
    ;$exp
    ; line 9
    push.c 0
    ;$par
    push.c 4
    sysreq.c 0    ; print
    stack 8
    ;$exp
    zero.pri
    retn


STKSIZE 1000
```

`dump` 的位置变了，这不重要——大型程序会在代码中散布多个 `dump` 语句，最终在编译的最后阶段合并。重点看 `dump` 的内容和加粗的两行。

尽管我们使用了变量，但在代码效率上与原始版本**完全相同**，因为我们仍然使用常量字符串。然而，存储两个字符串所需的内存减少了一半，两个实例都指向同一块内存。

你也可以使用 `new const` 或 `static stock const`，但在这里 `stock const` 可能是最好的选择，以避免警告并防止我们试图避免的内存重复。

如果你没有使用 `-d0` 参数，你的汇编输出可能会有所不同。

---

希望这些技巧对你有用！如果有任何问题或补充，欢迎讨论。
